/* 冒泡排序 */
function bubble(arr) {
  /* 冒泡排序的一点思考
  冒泡排序中，内层循环我是用了对象来储存，当前和上一个元素的值信息和位置指针。
  但是我忽略了一个重要问题，当一次循环完成后需要对上一个位置指针进行下移动，
  移动的时候直接用当前位置的对象赋值给上一个对象是不行的，因为此时数组没该位置的元素可能已经改变，
  当储存的元素信息是基本数据类型的时候，由于进行的是数据的拷贝，所以对象储存的值信息是不对的 */
  //进过一次循环遍历，会有一个最大位置的元素顺序一定被排列好
  // 重复循环元素个数次的 上面 1-5 步骤，所有元素的顺序都被排好
  for (let j = 0; j < arr.length - 1; j++) {
    //0. 定义上一个元素和当前所处元素的位置指针
    let prev = { index: null, val: null },
      current;
    //1. 对所有元素进行遍历
    for (let i = 0; i < arr.length; i++) {
      //2.判断上一个元素与当前元素大小
      current = {
        index: i,
        val: arr[i],
      };
      if (prev.val > current.val) {
        //3.如果当前元素小于上一个元素
        //3.1 把当前数组中当前元素所在位置上的元素和上一个元素的位置进行调换
        arr[current.index] = prev.val;
        arr[prev.index] = current.val;
      }
      //4. 如果当前元素大于上一个元素，下一步
      //5. 前一个元素指针位置向后移动
      prev = {
        index: i,
        val: arr[i],
      };
    }
  }
  return arr;
}
//内层循环负责，循环一次后，把最大的排在最后面，外层循环只控制循环次数， 只要让内层循环运行，长度减一次，就可以把所有顺序全部排列好
function bubble1(arr) {
  for (let j = 0; j < arr.length - 1; j++) {
    for (let i = 0; i < arr.length - 1; i++) {
      if (arr[i] > arr[i + 1]) {
        let tmp = arr[i];
        arr[i] = arr[i + 1];
        arr[i + 1] = tmp;
      }
    }
  }
  return arr;
}
//冒泡排序提升，每次内层循环已经排序好的不需要再次循环，因此由外层循环来控制循环的长度；
function bubble2(arr) {
  let j = arr.length;
  for (j; j > 0; j--) {
    for (let i = 0; i < j - 1; i++) {
      if (arr[i] > arr[i + 1]) {
        let tmp = arr[i];
        arr[i] = arr[i + 1];
        arr[i + 1] = tmp;
      }
    }
  }
  return arr;
}

/* 速度分析 */
console.time("arr");
bubble([
  11,
  4,
  5,
  22,
  65,
  76,
  1,
  3,
  7,
  65,
  223,
  62,
  412126,
  126126512,
  61236,
  2462,
  23,
  223,
  62,
  412126,
  126126512,
  61236,
  2462,
  23423423,
  423,
  4234,
  23623667868,
  6734,
  6,
  645,
  12321423423,
  423,
  4234,
  2,
  223,
  62,
  412126,
  126126512,
  61236,
  2462,
  23423423,
  423,
  4234,
  23623667868,
  6734,
  6,
  645,
  123213623667868,
  6734,
  6,
  645,
  12321,
]);
console.timeEnd("arr");

console.time("arr1");
bubble1([
  11,
  4,
  5,
  22,
  65,
  76,
  1,
  3,
  7,
  65,
  223,
  62,
  412126,
  126126512,
  61236,
  2462,
  23,
  223,
  62,
  412126,
  126126512,
  61236,
  2462,
  23423423,
  423,
  4234,
  23623667868,
  6734,
  6,
  645,
  12321423423,
  423,
  4234,
  2,
  223,
  62,
  412126,
  126126512,
  61236,
  2462,
  23423423,
  423,
  4234,
  23623667868,
  6734,
  6,
  645,
  123213623667868,
  6734,
  6,
  645,
  12321,
]);
console.timeEnd("arr1");

console.time("arr2");
bubble2([
  11,
  4,
  5,
  22,
  65,
  76,
  1,
  3,
  7,
  65,
  223,
  62,
  412126,
  126126512,
  61236,
  2462,
  23,
  223,
  62,
  412126,
  126126512,
  61236,
  2462,
  23423423,
  423,
  4234,
  23623667868,
  6734,
  6,
  645,
  12321423423,
  423,
  4234,
  2,
  223,
  62,
  412126,
  126126512,
  61236,
  2462,
  23423423,
  423,
  4234,
  23623667868,
  6734,
  6,
  645,
  123213623667868,
  6734,
  6,
  645,
  12321,
]);
console.timeEnd("arr2");

console.time("Array_sort");
Array.prototype.sort.call(
  [
    11,
    4,
    5,
    22,
    65,
    76,
    1,
    3,
    7,
    65,
    223,
    62,
    412126,
    126126512,
    61236,
    2462,
    23,
    223,
    62,
    412126,
    126126512,
    61236,
    2462,
    23423423,
    423,
    4234,
    23623667868,
    6734,
    6,
    645,
    12321423423,
    423,
    4234,
    2,
    223,
    62,
    412126,
    126126512,
    61236,
    2462,
    23423423,
    423,
    4234,
    23623667868,
    6734,
    6,
    645,
    123213623667868,
    6734,
    6,
    645,
    12321,
  ],
  (a, b) => a - b
);
console.timeEnd("Array_sort");
